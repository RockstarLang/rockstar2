@namespace Rockstar.Engine
@classname Parser
@using System.Globalization
@using System.Text.RegularExpressions
@using Rockstar.Engine.Statements
@using Rockstar.Engine.Expressions
@using Rockstar.Engine.Values
@trace true

@ignorecase true

program <Program>
	= EOS* head:block tail:program
		{ new Program(head).Concat(tail) }
	/ EOS* EOF
		{ new Program() }
	// unexpected:("" [^ \t\r\n]+) 
	//	#error{ $"Unexpected '{unexpected.Replace("\r", "\\r").Replace("\n", "\\n")}' at line {state.Line}, col {state.Column - unexpected.Length}" }

block <Block>
	= _? head:statement EOS tail:block
		{ new Block(head).Concat(tail) }
	/ _? stmt:statement
		{ new Block(stmt) }

statement
	= function
	/ function_call
	/ call_stmt
	/ return_stmt
	/ break_stmt
	/ continue_stmt
	/ loop
	/ conditional
	/ output_stmt
	/ assign_stmt
	/ enlist_stmt
	/ increment
	/ decrement
	/ mutation
	/ rounding
	// e:expression &EOS { new ExpressionStatement(e) }

enlist_stmt <Statement>
	= push _ e:expression _ into _ v:variable
		{ new Enlist(v, e) }
//	/ push _ v:variable _ like _ e:(literal/poetic_literal)
//		{ new Enlist(v, e) }
	/ push _ v:variable (_ with)? _ e:expression_list
		{ new Enlist(v, e) }
	/ push _ v:variable
		{ new Enlist(v) }
	/ d:delist _ into _ t:assignable
		{ new Assign(t, d) }

delist <Delist>
	= pop _ v:variable
		{ new Delist(v) }


return_stmt <Return>
	= return (_ back)? _ e:expression (_ back)?
		{ new Return(e) }

function <Statement>
	= name:variable _ takes _ null body:consequent
		{ new Assign(name, new Function(body)) }
	/ name:variable _ takes _ args:arguments body:consequent
		{ new Assign(name, new Function(args, body)) }

arguments <IEnumerable<Variable>>
	= head:variable _variable_list_separator_ tail:arguments
		{ head.Concat(tail) }
  / arg:variable { new List<Variable> { arg } }

_variable_list_separator_
	= _ and _
	/ _primary_list_separator_

break_stmt <Statement>
	= break wildcard
		{ new Break() }

continue_stmt <Statement>
	= continue
		{ new Continue() }

wildcard = (letter / _)* &EOS

EOB = EOL &EOL
    / EOS* &(_? else)
    / EOS* ','? _? end (_ / [,?!.;])*
    / EOS* ','? _? end (_ / [,?!.;])*
   	/ EOS* ','? _? 'o' &('o'+ 'h')
    / EOF

consequent <Block>
	= EOS b:block EOB { b }
	/ _ s:statement { new Block(s) }

conditional <Statement>
	= if _ e:expression (_ then)? c:consequent _? else a:consequent
		{ new Conditional(e, c, a) }
	/ if _ e:expression _ else a:consequent
		{ new Conditional(e, new Block(), a ) }
	/ if _ e:expression (_ then)? c:consequent
		{ new Conditional(e, c) }

loop <Statement>
	= while _ test:expression body:consequent
		{ new WhileLoop(test, body) }
	/ until _ test:expression body:consequent
		{ new UntilLoop(test,body) }

output_stmt <Statement>
	= write _ e:expression
		{ new Output(e) }
	/ print _ e:expression
		{ new Output(e, Environment.NewLine) }

binary_rhs <IEnumerable<Expression>>
	= primary_list
	/ e:expression { new List<Expression> { e } }

index <Expression>
	= _ at _ i:numeric_expression
		{ i }

indexes <IEnumerable<Expression>>
	= head:index tail:indexes
		{ head.Concat(tail) }
	/ head:index
		{ new List<Expression> { head } }

assignable <Variable>
	= v:variable i:indexes
		{ v.AtIndex(i) }
	/ v:variable { v }

assign_stmt <Statement>
	= put _ e:expression _ into _ v:assignable
		{ new Assign(v, e) }
	/ let _ v:assignable _ be op:_operator_ e:binary_rhs
		{ new Assign(v, new Binary(op, new Lookup(v), e)) }
	/ let _ v:assignable _ be _ e:expression
		{ new Assign(v, e) }
	/ v:assignable _ says_ s:poetic_string
		{ new Assign(v, s) }
	/ v:assignable (_? '=' _? / _is _) e:expression
		{ new Assign(v, e) }

	// BREAKING CHANGE
	/ v:assignable (_? '=' _? / _is _) p:v1_poetic_number 
		{ new Assign(v, p) }
	
	/ v:assignable _is op:_operator_ e:binary_rhs
		{ new Assign(v, new Binary(op, new Lookup(v), e)) }

_operator_ =
	_plus_ / _minus_ / _times_ / _divide_

says_ = says ("" ' '? / !letter)

poetic_string <Strïng>
	= s:("" [^\r\n]+) &('\r'? '\n')
		{ new Strïng(s) }

_is <Operator> -memoize
	= _is _ exactly
		{ Operator.IdenticalTo }
	/ ("'s" / "'re" / _ is)
		{ Operator.Equals }

_isnt <Operator> -memoize
	= _isnt _ exactly
		{ Operator.NotIdenticalTo }
	/ (_is _ not / _ isnt)
		{ Operator.NotEquals }

variable <Variable>
	= i:pronoun { new Pronoun(i) }
	/ i:proper_variable { new ProperVariable(i) }
	/ i:(the _ identifier) { new CommonVariable(i) }
	/ !keyword i:identifier { new SimpleVariable(i) }

proper_variable	= proper_noun (_ proper_noun)+

proper_noun	= !keyword &uppercase_letter identifier

identifier
	= letter (letter / [0-9_])*

letter = uppercase_letter / lowercase_letter

uppercase_letter = c:. &{ Char.IsUpper(c,0) }
lowercase_letter = c:. &{ Char.IsLower(c,0) }

expression <Expression>
	= boolean
	/ primary

boolean = binary_or

binary_or <Expression>
	= lhs:binary_nor _ or _ rhs:binary_or
		{ new Binary(Operator.Or, lhs, rhs) }
	/ binary_nor

binary_nor <Expression>
	= lhs:binary_and _ nor _ rhs:binary_nor
		{ new Binary(Operator.Nor, lhs, rhs) }
	/ binary_and

binary_and <Expression>
	= lhs:equality _ and _ rhs:binary_and
		{ new Binary(Operator.And, lhs, rhs) }
	/ equality

equality <Expression>
	= lhs:unary op:(_is / _isnt) _ rhs:equality
		{ new Binary(op, lhs, rhs) }
	/ unary

unary <Expression>
	= not_ u:unary
		{ new Unary(Operator.Not, u) }
	/ comparison

not_
	= (not _ / non _ / non '-' )

comparison <Expression>
	= lhs:addition op:comparator rhs:comparison
		{ new Binary(op, lhs, rhs) }
	/ addition 

comparator <Operator>
	= (_? '>' _?  / _is _ (above / more _ than) _) { Operator.MoreThan }
	/ (_? '<' _?  / _is _ (under / less _ than) _) { Operator.LessThan }
	/ (_? '>=' _? / _is _ as _ as_great _ as _) { Operator.MoreThanEqual }
	/ (_? '<=' _? / _is _ as _ as_small _ as _) { Operator.LessThanEqual }

numeric_expression
	= addition

addition <Expression> -memoize
	= lhs:addition op:(_plus_/_minus_) rhs:primary_list
		{ new Binary(op, lhs, rhs) }
	/ lhs:addition op:(_plus_/_minus_) rhs:product
		{ new Binary(op, lhs, rhs) }
	/ product

product <Expression> -memoize
	= lhs:product op:(_divide_/_times_) rhs:primary_list
		{ new Binary(op, lhs, rhs) }
	/ lhs:product op:(_divide_/_times_) rhs:primary
		{ new Binary(op, lhs, rhs) }
	/ primary

primary_list <IEnumerable<Expression>>
	= head:primary _primary_list_separator_ tail:primary_list
		{ head.Concat(tail) }
	/ head:primary _primary_list_separator_ tail:primary 
		{ new List<Expression> { head, tail } }

nacton = '&' / "n'" / "'n'"

_primary_list_separator_
	= ',' _? nacton _?
	/ _? nacton _?
	/ ',' _?

_plus_	<Operator>	= (_? '+' _? / _ plus _ ) { Operator.Plus }
_minus_ <Operator>	= (_? '-' _? / _ minus _ ) { Operator.Minus }
_times_	<Operator>	= (_? '*' _? / _ times _ ) { Operator.Times }
_divide_ <Operator>	= (_? '/' _? / _ divided_by _ ) { Operator.Divide }

primary <Expression>
	= function_call
	/ delist
	/ constant
	/ string
	/ number
	/ lookup
	// unexpected:("" [^ \t\r\n]+) 
	//	#error{ $"Expected primary expression, found '{unexpected}' at line {state.Line}, col {state.Column - unexpected.Length}" }

call_stmt <Statement>
	= name:variable &'!'
		{ new FunctionCall(name) }
	/ call _ name:variable
		{ new FunctionCall(name) }		

function_call <FunctionCall>
	= name:variable _ taking _ args:expression_list
		{ new FunctionCall(name, args) }

expression_list <IEnumerable<Expression>>
	= head:expression _expression_list_separator_ tail:expression_list
		{ head.Concat(tail) }
	/ expr:expression
		{ new List<Expression> { expr } }

_expression_list_separator_
	= _? ', ' and _
	/ _primary_list_separator_

lookup <Expression>
	= v:variable i:indexes
		{ new Lookup(v.AtIndex(i)) }
	/ v:variable
		{ new Lookup(v) }

increment <Increment>
	= build _ v:variable _ t:(up _)+
		{ new Increment(v, t.Count) }

decrement <Decrement>
	= knock _ v:variable _ t:(down _)+
		{ new Decrement(v, t.Count) }

mutator <Operator>
	= split
		{ Operator.Split }
	/ cast
		{ Operator.Cast }
	/ join
		{ Operator.Join }

mutation <Statement>
	= op:mutator _ s:expression _ into _ t:assignable _ using _ m:expression
		{ new Mutation(op, s, target: t, m) }
	/ op:mutator _ s:expression _ into _ t:assignable
		{ new Mutation(op, s, target: t) }
	/op:mutator _ s:assignable _ using _ m:expression
		{ new Mutation(op, s, target: s, modifier: m) }
	/ op:mutator _ s:assignable
		{ new Mutation(op, s, target: s) }

rounding <Statement>
	= floor / ceil / math_round

floor <Statement>
	= turn _ v:variable _ down
		{ new Rounding(v, Round.Down) }
	/ turn _ down _ v:variable
		{ new Rounding(v, Round.Down) }

ceil <Statement>
	= turn _ v:variable _ up
		{ new Rounding(v, Round.Up) }
	/ turn _ up _ v:variable
		{ new Rounding(v, Round.Up) }

math_round <Statement>
	= turn _ v:variable _ around
		{ new Rounding(v, Round.Nearest) }
	/ turn _ around _ v:variable
		{ new Rounding(v, Round.Nearest) }


constant <Value>	
	= null { Null.Instance }
	/ true { Booleän.True }
	/ false { Booleän.False }
	/ empty { Strïng.Empty }

number <Number>
    = like _ n:poetic_number { n }
	/ d:digits&{ decimal.TryParse(d, out var _) }
		{ new Number(d) }
	/ d:digits
		#error{ $"Number {d} is out of range" }
digits
	= d:("" (('-' /'+')? [0-9]+ ("." [0-9]+)?)
	/ (('-' /'+')? "." [0-9]+))	

poetic_number <Number>
	= whole_part:poetic_digits _? ('...' / '…') _ fractional_part:poetic_digits
		{ new Number (whole_part + "." + fractional_part) }
	/ digits:poetic_digits
		{ new Number(digits) }

v1_poetic_number <Number>
	= !keyword whole_part:poetic_digits _? ('.') _ fractional_part:poetic_digits
		{ new Number (whole_part + "." + fractional_part) }
	/ !keyword digits:poetic_digits
		{ new Number(digits) }


PDS = ("" _ / [0-9\',;:?!+_/] )

poetic_digits <string>
	= PDS* head:poetic_digit PDS+ tail:poetic_digits PDS* 
		{ head + tail }
	/ d:poetic_digit
		{ d }

poetic_digit <string>
	= word:("" (letter / [\-'])+)
		{ (Regex.Replace(word, "'+", "").Length % 10).ToString() }

string <Strïng> = s:quoted_string+ { new Strïng(String.Join("\"", s)) }
quoted_string
	= '"' s:("" [^"]*) '"' { s }

at = 'at' !letter
turn = 'turn' !letter
around = 'around' !letter / 'round' !letter
using = 'using' !letter / 'with' !letter
split = 'cut' !letter / 'split' !letter / 'shatter' !letter
cast = 'cast' !letter / 'burn' !letter
join = 'join' !letter / 'unite' !letter
mysterious = 'mysterious' !letter
plus = 'plus' !letter / 'with' !letter
minus = 'minus' !letter / 'without' !letter
times = 'times' !letter / 'of' !letter
over = 'over' !letter
under = 'under' !letter
above = 'above' !letter / over
divided_by = 'divided' _ 'by' !letter / 'between' !letter / over
as = 'as' !letter
isnt = "isnt" !letter / "isn't" !letter / 'aint' !letter / "ain't" !letter
	/ "wasn't" !letter / "wasnt" !letter / "aren't" !letter / "arent" !letter
	/ "weren't" !letter / "werent" !letter 
not = 'not' !letter
non = 'non' !letter
nor = 'nor' !letter
is = 'is' !letter / 'was' !letter / 'are' !letter / 'were' !letter
put = 'put' !letter
into = 'into' !letter / 'in' !letter
let = 'let' !letter
be = 'be' !letter
listen = 'listen' !letter
to = 'to' !letter
while = 'while' !letter
until = 'until' !letter
else = 'else' !letter / 'otherwise' !letter
end = 'end' !letter / 'yeah' !letter / 'baby' !letter / 'oh' !letter
if = 'if' !letter / 'when' !letter
build = 'build' !letter
up = 'up' !letter
down = 'down' !letter
knock = 'knock' !letter
exactly = 'exactly' !letter / 'totally' !letter / 'really' !letter
and = 'and' !letter
or = 'or' !letter
back = 'back' !letter
taking = 'taking' !letter
return = 'return' !letter / 'giving' !letter / 'give' !letter / 'send' !letter
takes = 'takes' !letter / 'wants' !letter
says = 'say' !letter / 'says' !letter / 'said' !letter
pronoun	= 'they' !letter / 'them'!letter / 'she' !letter / 'him' !letter / 'her' !letter / 'hir' !letter/ 'zie' !letter/ 'zir' !letter/ 'xem' !letter/ 'ver'!letter
    / 'ze' !letter/ 've' !letter/ 'xe' !letter/ 'it' !letter/ 'he'!letter
	/ 'you' !letter / 'me' !letter / 'i' !letter
the	= 'an'  !letter/ 'a'  !letter / 'the'  !letter / 'my'  !letter / 'your'  !letter / 'our' !letter
more = 'greater'/ 'higher' / 'bigger' / 'stronger' !letter/ 'more' !letter

less = 'less' !letter/ 'lower'	/ 'smaller' !letter/ 'weaker' !letter
as_great = 'great' !letter/ 'high' !letter/ 'big' !letter/ 'strong' !letter
as_small = 'less' !letter/ 'low' !letter/ 'small' !letter/ 'weak' !letter
than = 'than' !letter
empty = 'empty' !letter / 'silent' !letter / 'silence' !letter
true = "true" !letter/ "yes" !letter/ "ok" !letter/ "right"!letter 
false = "false" !letter/ "lies" !letter/ "no" !letter/ "wrong"!letter
null = 'null' !letter/ 'nothing' !letter/ 'nowhere' !letter/ 'nobody' !letter/ 'gone'!letter
print = "print" !letter / "shout" !letter / "say" !letter / "scream" !letter / "whisper" !letter
break = 'break' !letter
continue = 'continue' !letter / 'take' !letter
push = 'rock' !letter / 'push' !letter
pop = 'roll' !letter / 'pop' !letter
with = 'with' !letter
like = 'like' !letter / 'so' !letter
then = 'then' !letter
write = 'write' !letter / 'whisper' !letter
call = 'call' !letter

keyword
	= and 
	/ as 
	/ as_great 
	/ as_small 
	/ back 
	/ be 
	/ build
	/ cast
	/ divided_by
	/ down 
	/ else 
	/ empty 
	/ end
	/ false 
	/ if 
	/ into 
	/ is 
	/ isnt
	/ join
	/ knock 
	/ less 
	/ let 
	/ listen 
	/ minus 
	/ more 
	/ mysterious 
	/ non 
	/ not 
	/ null 
	/ or 
	/ over 
	/ plus 
	/ print 
	/ pronoun 
	/ put 
	/ return 
	/ says
	/ split
	/ takes 
	/ taking 
	/ than 
	/ the
	/ times 
	/ to 
	/ true 
	/ until 
	/ up 
	/ while	

_ = "" (whitespace / comment)+
whitespace = [ \t]
comment	=
	'#' [^\n]* '\n'
	/ '(' [^)]* ')'
	/ '{' [^\}]* '}'
	/ '[' [^\]]* ']'

EOS = [,.?!;: \t]* EOL
	/ _? [,.?!;:]	
EOL = _? '\r'? '\n'
EOF = EOL* _? !.
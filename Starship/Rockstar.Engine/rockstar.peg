@namespace Rockstar.Engine
@classname Parser
@using System.Globalization
@using System.Text.RegularExpressions
@using Rockstar.Engine.Statements
@using Rockstar.Engine.Expressions
@using Rockstar.Engine.Values;
@trace true

@ignorecase true

program <Progräm>
	= ("" _ / EOL)+ p:program
		{ p }
	/ head:statement EOS+ tail:program
		{ tail.Insert(head) }
	/ head:statement tail:program
		{ tail.Insert(head) }
	/ ("" _ / EOL)* EOF
		{ new Progräm() }

EOL = '\r'? '\n'
EOS	= _? EOL _?
EOF	= !.
	/ unexpected:. #error{ "Unexpected character '" + Regex.Escape(unexpected) + "' at line " + state.Line + ", col " + (state.Column-1) }

_	= (whitespace / comment)+

whitespace = [ \t]

comment
	= '(' [^)]* ')'
	/ '{' [^\}]* '}'
	/ '[' [^\]]* ']'

statement <Statement>
	= output_stmt
	/ assign_stmt

assign_stmt <Statement>
	= 'let' _ v:variable _ 'be' _ e:expression
		{ new Assign(v, e, state.Source()) }
	/ 'put' _ e:expression _ 'into' _ v:variable 
		{ new Assign(v, e, state.Source()) }
	/ v:variable _ says _ s:("" [^\r\n]*) 
		{ new Assign(v, new Strïng(s, state.Source(s)), state.Source()) }
	/ v:variable _is _ l:(literal / poetic_literal)
		{ new Assign(v, l, state.Source()) }

	//TODO: reinstate for 2.0
	// v:variable _is _ e:expression { new Assign(v, e, state.Source()) }

says = ('says' / 'say' / 'said')

poetic_literal <Number>
	= whole_part:poetic_digits _? '.' _? fractional_part:poetic_digits
		{ new Number (whole_part + "." + fractional_part) }
	/ digits:poetic_digits
		{ new Number(digits) }

poetic_digits <string>
	= head:poetic_digit _ tail:poetic_digits
		{ head + tail }
	/ d:poetic_digit { d }

poetic_digit <string>
	= word:("" [A-Za-z\-']+)
		{ (word.Length % 10).ToString() }

output_stmt  <Statement>
	= output _ e:expression { new Output(e, state.Source()) }

variable <Variable>
	= p:pronoun { new Pronoun(p, state.Source(p)) }
	/ n:common_variable { new CommonVariable(n, state.Source(n)) }
	/ n:proper_variable { new ProperVariable(n, state.Source(n)) }
	/ n:simple_variable { new SimpleVariable(n, state.Source(n)) }

pronoun
	= 'they' / 'them'
    / 'she' / 'him' / 'her' / 'hir' / 'zie' / 'zir' / 'xem' / 'ver'
    / 'ze' / 've' / 'xe' / 'it' / 'he'

proper_variable	// e.g. Big Bad Benny
	= proper_noun (_ proper_noun)*

proper_noun
	= !keyword uppercase_letter letter*

keyword = is / common_prefix / pronoun / 

common_variable
	= common_prefix _ simple_variable

common_prefix
	= 'an' / 'a' / 'the' / 'my' / 'your' / 'our'

simple_variable
	= ("" letter+)

letter
	= uppercase_letter / lowercase_letter

uppercase_letter
	= [A-ZÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĸĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸŹŻŽ]s

lowercase_letter
	= [a-zàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĳĵķĸĺļľŀłńņňŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷÿźżžŉß]s

expression <Expression>
	= unary
	/ variable

unary <Expression>
	= op:unary_op ex:expression
		{ new Unary(op, ex, state.Source()) }
	/ or

// nor	 <Expression>
// 	= lhs:or _ 'nor' rhs:or
// 		{ new Binary(Operator.Nor, lhs, rhs, state.Source()) }
// 	/ or

or <Expression>
	= lhs:and _ 'or' _ rhs:or
		{ new Binary(Operator.Or, lhs, rhs, state.Source()) }
	/ and

and <Expression>
	= lhs:equals _ 'and' _ rhs:and
		{ new Binary(Operator.And, lhs, rhs, state.Source()) }
	/ equals

equals <Expression>
	= lhs:not op:_eq _ rhs:equals
		{ new Binary(op,lhs,rhs, state.Source()) }
	/ not

not <Expression>
	= ('non-' / 'non' _ / 'not' _ ) ex:not { new Unary(Operator.Not, ex, state.Source()) }
	/ compare

compare <Expression>
	= lhs:math op:comparator _ rhs:compare
		{ new Binary(op, lhs, rhs, state.Source()) }
	/ math

gtr = ("greater"/ "higher"	/ "bigger"	/ "stronger" )
ltr = ("less" / "lower"	/ "smaller" / "weaker" )
gte = ("great" / "high" / "big" / "strong" )
lte = ("less" / "low" / "small" / "weak" )

comparator <Operator>
	= _is _ gtr _ 'than' { Operator.MoreThan }
	/ _is _ ltr _ 'than' { Operator.LessThan }
	/ _is _ 'as' _ gte _ 'as' { Operator.MoreThanEqual }
	/ _is _ 'as' _ lte _ 'as' { Operator.LessThanEqual }

_eq
	= _is_not
	/ _is

_is <Operator>
	= ("'s" / "'re" / _ ('=' / is)) !letter
		{ Operator.Equals }

is = 'is' / 'was' / 'are' / 'were'

_is_not <Operator>
	= _ ('!=' / _is _ "not" / "isnt" / "isn't" / 'aint' / "ain't" / "wasn't" / "wasnt" / "aren't" / "arent" / "weren't" / "werent") !letter
		{ Operator.NotEquals }

math <Expression>
	= sum

sum <Expression> -memoize
	= lhs:sum op:(plus/minus) rhs:product { new Binary(op, lhs, rhs, state.Source()) }
	/ product

product <Expression> -memoize
	= lhs:product op:(times/divide) rhs:primary { new Binary(op, lhs, rhs, state.Source()) }
	/ primary

plus	<Operator>	= (_? '+' _? / _ 'plus' _ / _ 'with' _ ) { Operator.Plus }
minus	<Operator>	= (_? '-' _? / _ 'minus' _ / _ 'without' _ ) { Operator.Minus }
times	<Operator>	= (_? '*' _? / _ 'times' _ / _ 'of' _ ) { Operator.Times }
divide	<Operator>	= (_? '/' _? / _ 'over' _ / _ 'between' _ ) { Operator.Divide }

primary <Expression>
	= literal
	/ lookup

lookup <Expression>
	= v:variable
		{ new Looküp(v, state.Source()) }

literal <Expression>
	= constant
	/ number
	/ string

constant <Expression>
	= t:true { new Booleän(true, state.Source(t)) }
	/ f:false { new Booleän(true, state.Source(f)) }
	/ n:null { new Null(state.Source(n)) }
	/ m:'mysterious' { Mysterious.Instance }

true
	= "true" / "yes" / "ok" / "right"
false
	= "false" / "lies" / "no" / "wrong" 
null
	= 'null' / 'nothing' / 'nowhere' / 'nobody' / 'gone'

string <Strïng>
	= '"' contents:("" [^"]*) '"' { new Strïng(contents, state.Source(contents)) }

number <Number>
    = digits:([0-9]+ ("." [0-9]+)?) { new Number(Decimal.Parse(digits), state.Source(digits) ) }

unary_op <Operator>
	= not { Operator.Not }
	/ minus { Operator.Minus }

output		= "shout" / "say" / "scream" / "whisper"

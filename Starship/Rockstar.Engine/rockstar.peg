@namespace Rockstar.Engine
@classname Parser
@using System.Globalization
@using System.Text.RegularExpressions
@using Rockstar.Engine.Statements
@using Rockstar.Engine.Expressions
@using Rockstar.Engine.Values;
@trace true

@ignorecase true

program <Block>
	= __ head:block tail:program
		{ head.Concat(tail) }
	/ __ EOF
		{ new Block() }

__ = ("" _ / EOL)*

block <Block>
	= head:statement EOS tail:block
		{ tail.Insert(head) }
	/ s:statement EOS
		{ new Block(s) }

EOS	= _? EOL _?
	/ EOF
EOL = '\r'? '\n'
EOF	= !.
	/ unexpected:("" [^ \t\r\n]+) 
		#error{ $"Unexpected '{Regex.Escape(unexpected)}' at line {state.Line}, col {state.Column - 1}" }

statement <Statement>
	= loop
	/ alternate
	/ output_stmt
	/ assign_stmt
	/ increment
	/ decrement

noise 	= (_ / [;,])

increment <Increment>
	= 'build'i _ v:variable _ t:('up' noise*)+
		{ new Increment(v, t.Count, state.Source()) }

decrement <Decrement>
	= 'knock'i _ v:variable _ t:('down' noise*)+
		{ new Decrement(v, t.Count, state.Source()) }

chonk <Block>
	= EOS b:block
		{ b }
	/ _ s:statement
		{ new Block(s) }

alternate <Conditional>
	= c:conditional _? 'else' a:chonk
		{ c.Else(a) }
	/ c:conditional EOS 'else' a:chonk
		{ c.Else(a) }
	/ c:conditional { c }

conditional <Conditional>
	= 'if' _ e:expression c:chonk
		{ new Conditional(e, c, state.Source()) }

loop <Loop>
	= 'while' _ e:expression _ s:statement
		{ new WhileLoop(e, new Block(s), state.Source()) }
	/ 'while' _ e:expression EOS b:block
		{ new WhileLoop(e, b, state.Source()) }
	/ 'until' _ e:expression _ s:statement
		{ new UntilLoop(e, new Block(s), state.Source()) }
	/ 'until' _ e:expression EOS b:block
		{ new UntilLoop(e, b, state.Source()) }

assign_stmt <Statement>
	= 'put' _ e:expression _ 'into' _ v:variable
		{ new Assign(v, e, state.Source()) }
	/ 'let' _ v:variable _ 'be' o:_op_ e:expression
		{ new Assign(v, new Binary(o, new Looküp(v, state.Source()), e, state.Source()), state.Source()) }
	/ 'let' _ v:variable _ 'be' _ e:expression
		{ new Assign(v, e, state.Source()) }
	/ v:variable _ says _ s:("" [^\r\n]*) 
		{ new Assign(v, new Strïng(s, state.Source(s)), state.Source()) }
	/ v:variable _is _ l:(literal / poetic_literal)
		{ new Assign(v, l, state.Source()) }

	//TODO: reinstate for 2.0
	// v:variable _is _ e:expression { new Assign(v, e, state.Source()) }

says = ('says' / 'said')

poetic_literal <Number>
	= whole_part:poetic_digits _? '.' _? fractional_part:poetic_digits
		{ new Number (whole_part + "." + fractional_part) }
	/ digits:poetic_digits
		{ new Number(digits) }

PDS = ("" _ / [0-9\',;:?!+_/] )

poetic_digits <string>
	= PDS* head:poetic_digit PDS+ tail:poetic_digits PDS* 
		{ head + tail }
	/ d:poetic_digit
		{ d }

poetic_digit <string>
	= word:("" [A-Za-z\-']+)
		{ (Regex.Replace(word, "'+", "").Length % 10).ToString() }

output_stmt  <Statement>
	= output _ e:expression { new Output(e, state.Source()) }

variable <Variable>
	= p:pronoun { new Pronoun(p, state.Source(p)) }
	/ n:common_variable { new CommonVariable(n, state.Source(n)) }
	/ n:proper_variable { new ProperVariable(n, state.Source(n)) }
	/ n:simple_variable { new SimpleVariable(n, state.Source(n)) }

pronoun
	= ('they' / 'them'
    / 'she' / 'him' / 'her' / 'hir' / 'zie' / 'zir' / 'xem' / 'ver'
    / 'ze' / 've' / 'xe' / 'it' / 'he') !letter

proper_variable	// e.g. Big Bad Benny
	= proper_noun (_ proper_noun)+

proper_noun
	= !keyword uppercase_letter letter*

keyword = (is / common_prefix / pronoun / 'let' / 'with') !letter

common_variable
	= common_prefix _ simple_variable

common_prefix
	= ('an' / 'a' / 'the' / 'my' / 'your' / 'our') !letter

simple_variable
	= !keyword ("" letter (letter / [0-9])*)

letter
	= uppercase_letter / lowercase_letter

uppercase_letter
	= [A-ZÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĸĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸŹŻŽ]s

lowercase_letter
	= [a-zàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĳĵķĸĺļľŀłńņňŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷÿźżžŉß]s

expression <Expression>
	= unary
	/ variable

unary <Expression>
	= op:unary_op ex:expression
		{ new Unary(op, ex, state.Source()) }
	/ or

// nor	 <Expression>
// 	= lhs:or _ 'nor' rhs:or
// 		{ new Binary(Operator.Nor, lhs, rhs, state.Source()) }
// 	/ or

or <Expression>
	= lhs:and _ 'or' _ rhs:or
		{ new Binary(Operator.Or, lhs, rhs, state.Source()) }
	/ and

and <Expression>
	= lhs:equals _ 'and' _ rhs:and
		{ new Binary(Operator.And, lhs, rhs, state.Source()) }
	/ equals

equals <Expression>
	= lhs:not op:_eq _ rhs:equals
		{ new Binary(op,lhs,rhs, state.Source()) }
	/ not

not <Expression>
	= ('non-' / 'non' _ / 'not' _ ) ex:not { new Unary(Operator.Not, ex, state.Source()) }
	/ compare

compare <Expression>
	= lhs:math op:comparator _ rhs:compare
		{ new Binary(op, lhs, rhs, state.Source()) }
	/ math

gtr = ('greater'/ 'higher'	/ 'bigger'	/ 'stronger' / 'more' )
ltr = ('less' / 'lower'	/ 'smaller' / 'weaker' )
gte = ('great' / 'high' / 'big' / 'strong' )
lte = ('less' / 'low' / 'small' / 'weak' )

comparator <Operator>
	= _is _ gtr _ 'than' { Operator.MoreThan }
	/ _is _ ltr _ 'than' { Operator.LessThan }
	/ _is _ 'as' _ gte _ 'as' { Operator.MoreThanEqual }
	/ _is _ 'as' _ lte _ 'as' { Operator.LessThanEqual }

_eq
	= _is_not
	/ _is

_is <Operator>
	= ("'s" / "'re" / _ ('=' / is)) !letter
		{ Operator.Equals }

is = 'is' / 'was' / 'are' / 'were'

_is_not <Operator>
	= _ ('!=' / _is _ "not" / "isnt" / "isn't" / 'aint' / "ain't" / "wasn't" / "wasnt" / "aren't" / "arent" / "weren't" / "werent") !letter
		{ Operator.NotEquals }

math <Expression>
	= sum

sum <Expression> -memoize
	= lhs:sum op:(_plus_/_minus_) rhs:product { new Binary(op, lhs, rhs, state.Source()) }
	/ product

product <Expression> -memoize
	= lhs:product op:(_times_/_divide_) rhs:primary { new Binary(op, lhs, rhs, state.Source()) }
	/ primary

_plus_	<Operator>	= (_? '+' _? / _ 'plus' _ / _ 'with' _ ) { Operator.Plus }
_minus_	<Operator>	= (_? '-' _? / _ 'minus' _ / _ 'without' _ ) { Operator.Minus }
_times_	<Operator>	= (_? '*' _? / _ 'times' _ / _ 'of' _ ) { Operator.Times }
_divide_	<Operator>	= (_? '/' _? / _ 'over' _ / _ 'between' _ ) { Operator.Divide }

_op_ <Operator>
	= _plus_ / _minus_ / _times_ / _divide_

primary <Expression>
	= literal
	/ lookup

lookup <Expression>
	= v:variable
		{ new Looküp(v, state.Source()) }

literal <Expression>
	= constant
	/ number
	/ string

constant <Expression>
	= t:true { new Booleän(true, state.Source(t)) }
	/ f:false { new Booleän(false, state.Source(f)) }
	/ n:null { new Null(state.Source(n)) }
	/ m:'mysterious' { Mysterious.Instance }
	/ e:empty { Strïng.Empty }

empty
	= ('empty'i / 'silent'i / 'silence'i)

true
	= ("true" / "yes" / "ok" / "right") !letter
false
	= ("false" / "lies" / "no" / "wrong") !letter 
null
	= ('null' / 'nothing' / 'nowhere' / 'nobody' / 'gone') !letter

string <Strïng>
	= '"' contents:("" [^"]*) '"' { new Strïng(contents, state.Source(contents)) }

number <Number>
    = digits:('-'? [0-9]+ ("." [0-9]+)?) { new Number(Decimal.Parse(digits), state.Source(digits) ) }
	/ digits:('-'? "." [0-9]+) { new Number(Decimal.Parse(digits), state.Source(digits) ) }

unary_op <Operator>
	= not { Operator.Not }
	/ _minus_ { Operator.Minus }

output
	= "shout" / "say" / "scream" / "whisper"

_	= "" (whitespace / comment)+
whitespace = [ \t]
comment	= '(' [^)]* ')'	/ '{' [^\}]* '}' / '[' [^\]]* ']'
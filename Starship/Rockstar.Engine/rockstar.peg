@namespace Rockstar.Engine
@classname Parser
@using System.Globalization
@using System.Text.RegularExpressions
@using Rockstar.Engine.Statements
@using Rockstar.Engine.Expressions
@using Rockstar.Engine.Values
@trace true

@ignorecase true

program <Program>
	= EOS* head:block tail:program
		{ new Program(head).Concat(tail) }
	/ EOS* EOF
		{ new Program() }

block <Block>
	= _? head:statement EOS tail:block
		{ new Block(head).Concat(tail) }
	/ _? stmt:statement
		{ new Block(stmt) }

statement = output_stmt / assign_stmt

output_stmt <Statement>
	= print _ e:expression
		{ new Output(e) }

binary_rhs <IEnumerable<Expression>>
	= primary_list
	/ e:expression { new List<Expression> { e } }

assign_stmt <Statement>
	= put _ e:expression _ into _ v:variable
		{ new Assign(v, e) }
	/ let _ v:variable _ be op:_operator_ e:binary_rhs
		{ new Assign(v, new Binary(op, new Lookup(v), e)) }
	/ let _ v:variable _ be _ e:expression
		{ new Assign(v, e) }
	/ v:variable _is op:_operator_ e:binary_rhs
		{ new Assign(v, new Binary(op, new Lookup(v), e)) }
	/ v:variable _ says_ s:poetic_string
		{ new Assign(v, s) }
	/ v:variable _is _ e:expression
		{ new Assign(v, e) }

_operator_ =
	_plus_ / _minus_ / _times_ / _divide_

says_ = says ("" ' '? / !letter)

poetic_string <Strïng>
	= s:("" [^\r\n]+) &('\r'? '\n')
		{ new Strïng(s) }

_is <Operator> -memoize
	= _is _ exactly
		{ Operator.IdenticalTo }
	/ ("'s" / "'re" / _ is)
		{ Operator.Equals }

_isnt <Operator> -memoize
	= _isnt _ exactly
		{ Operator.NotIdenticalTo }
	/ (_is _ not / _ isnt)
		{ Operator.NotEquals }

variable <Variable>
	= i:pronoun { new Pronoun(i) }
	/ i:proper_variable { new ProperVariable(i) }
	/ i:(the _ identifier) { new CommonVariable(i) }
	/ i:identifier { new SimpleVariable(i) }

proper_variable	= proper_noun (_ proper_noun)+

proper_noun	= !keyword &uppercase_letter identifier

identifier
	= letter (letter / [0-9_])*

letter = uppercase_letter / lowercase_letter

uppercase_letter = c:. &{ Char.IsUpper(c,0) }
lowercase_letter = c:. &{ Char.IsLower(c,0) }

expression <Expression>
	= boolean
	/ primary

boolean = binary_or

binary_or <Expression>
	= lhs:binary_nor _ or _ rhs:binary_or
		{ new Binary(Operator.Or, lhs, rhs) }
	/ binary_nor

binary_nor <Expression>
	= lhs:binary_and _ nor _ rhs:binary_nor
		{ new Binary(Operator.Nor, lhs, rhs) }
	/ binary_and

binary_and <Expression>
	= lhs:equality _ and _ rhs:binary_and
		{ new Binary(Operator.And, lhs, rhs) }
	/ equality

equality <Expression>
	= lhs:unary op:(_is / _isnt) _ rhs:equality
		{ new Binary(op, lhs, rhs) }
	/ unary

unary <Expression>
	= not_ u:unary
		{ new Unary(Operator.Not, u) }
	/ comparison

not_
	= (not _ / non _ / non '-' )

comparison <Expression>
	= lhs:addition op:comparator _ rhs:comparison
		{ new Binary(op, lhs, rhs) }
	/ addition 

comparator <Operator>
	= _is _ gtr _ than { Operator.MoreThan }
	/ _is _ ltr _ than { Operator.LessThan }
	/ _is _ as _ gte _ as { Operator.MoreThanEqual }
	/ _is _ as _ lte _ as { Operator.LessThanEqual }

addition <Expression> -memoize
	= lhs:addition op:(_plus_/_minus_) rhs:primary_list
		{ new Binary(op, lhs, rhs) }
	/ lhs:addition op:(_plus_/_minus_) rhs:product
		{ new Binary(op, lhs, rhs) }
	/ product

product <Expression> -memoize
	= lhs:product op:(_divide_/_times_) rhs:primary_list
		{ new Binary(op, lhs, rhs) }
	/ lhs:product op:(_divide_/_times_) rhs:primary
		{ new Binary(op, lhs, rhs) }
	/ primary

primary_list <IEnumerable<Expression>>
	= head:primary _primary_list_separator_ tail:primary_list
		{ head.Concat(tail) }
	/ head:primary _primary_list_separator_ tail:primary 
		{ new List<Expression> { head, tail } }

_primary_list_separator_		
	= (_? ', ' and _ / _? ('&' / ',' / "n'" / "'n'") _?)

_plus_	<Operator>	= (_? '+' _? / _ plus _ ) { Operator.Plus }
_minus_ <Operator>	= (_? '-' _? / _ minus _ ) { Operator.Minus }
_times_	<Operator>	= (_? '*' _? / _ times _ ) { Operator.Times }
_divide_ <Operator>	= (_? '/' _? / _ over _ ) { Operator.Divide }

primary <Expression>
	= constant
	/ string
	/ number
	/ lookup
	/ unexpected:("" [^ \t\r\n]+) 
		#error{ $"Expected primary expression, found '{unexpected}' at line {state.Line}, col {state.Column - unexpected.Length}" }

lookup <Expression>
	= v:variable
		{ new Lookup(v) }

constant <Value>	
	= null { Null.Instance }
	/ true { Booleän.True }
	/ false { Booleän.False }
	/ empty { Strïng.Empty }

number <Number>
    = 'like' _ n:poetic_number { n }
	/ d:digits&{ decimal.TryParse(d, out var value) }
		{ new Number(d) }
	/ d:digits
		#error{ $"Number {d} is out of range" }
digits 
	= ("" (('-' /'+')? [0-9]+ ("." [0-9]+)?) / (('-' /'+')? "." [0-9]+))	

poetic_number <Number>
	= whole_part:poetic_digits _? ('...' / '…') _ fractional_part:poetic_digits
		{ new Number (whole_part + "." + fractional_part) }
	/ digits:poetic_digits
		{ new Number(digits) }

PDS = ("" _ / [0-9\',;:?!+_/] )

poetic_digits <string>
	= PDS* head:poetic_digit PDS+ tail:poetic_digits PDS* 
		{ head + tail }
	/ d:poetic_digit
		{ d }

poetic_digit <string>
	= word:("" (letter / [\-'])+)
		{ (Regex.Replace(word, "'+", "").Length % 10).ToString() }

string <Strïng> = s:quoted_string+ { new Strïng(String.Join("\"", s)) }
quoted_string
	= '"' s:("" [^"]*) '"' { s }

at = 'at' !letter
turn = 'turn' !letter
around = 'around' !letter / 'round' !letter
using = 'using' !letter / 'with' !letter
split = 'cut' !letter / 'split' !letter / 'shatter' !letter
cast = 'cast' !letter / 'burn' !letter
join = 'join' !letter / 'unite' !letter
mysterious = 'mysterious' !letter
plus = 'plus' !letter / 'with' !letter
minus = 'minus' !letter / 'without' !letter
times = 'times' !letter / 'of' !letter
over = 'over' !letter / 'between' !letter
as = 'as' !letter
isnt = "isnt" !letter / "isn't" !letter / 'aint' !letter / "ain't" !letter
	/ "wasn't" !letter / "wasnt" !letter / "aren't" !letter / "arent" !letter
	/ "weren't" !letter / "werent" !letter 
not = 'not' !letter
non = 'non' !letter
nor = 'nor' !letter
is = 'is' !letter / 'was' !letter / 'are' !letter / 'were' !letter
put = 'put' !letter
into = 'into' !letter / 'in' !letter
let = 'let' !letter
be = 'be' !letter
listen = 'listen' !letter
to = 'to' !letter
while = 'while' !letter
until = 'until' !letter
else = 'else' !letter
if = 'if' !letter
build = 'build' !letter
up = 'up' !letter
down = 'down' !letter
knock = 'knock' !letter
exactly = 'exactly' !letter / 'totally' !letter / 'really' !letter
and = 'and' !letter
or = 'or' !letter
back = 'back' !letter
taking = 'taking' !letter
give = 'return' !letter / 'give' !letter / 'send' !letter
takes = 'takes' !letter / 'wants' !letter
says = 'says' !letter / 'said' !letter
pronoun	= 'they' !letter / 'them'!letter / 'she' !letter / 'him' !letter / 'her' !letter / 'hir' !letter/ 'zie' !letter/ 'zir' !letter/ 'xem' !letter/ 'ver'!letter
    / 'ze' !letter/ 've' !letter/ 'xe' !letter/ 'it' !letter/ 'he'!letter
the	= 'an'  !letter/ 'a'  !letter / 'the'  !letter / 'my'  !letter / 'your'  !letter / 'our' !letter
gtr = 'greater'/ 'higher' / 'bigger' / 'stronger' !letter/ 'more' !letter
ltr = 'less' !letter/ 'lower'	/ 'smaller' !letter/ 'weaker' !letter
gte = 'great' !letter/ 'high' !letter/ 'big' !letter/ 'strong' !letter
lte = 'less' !letter/ 'low' !letter/ 'small' !letter/ 'weak' !letter
than = 'than' !letter
empty = 'empty' !letter / 'silent' !letter / 'silence' !letter
true = "true" !letter/ "yes" !letter/ "ok" !letter/ "right"!letter 
false = "false" !letter/ "lies" !letter/ "no" !letter/ "wrong"!letter
null = 'null' !letter/ 'nothing' !letter/ 'nowhere' !letter/ 'nobody' !letter/ 'gone'!letter
print = "print" !letter / "shout" !letter / "say" !letter / "scream" !letter / "whisper" !letter
break = 'break' !letter
continue = 'continue' !letter / 'take' _ 'it' _ 'to' _ 'the' _ 'top' !letter
push = 'rock' !letter / 'push' !letter
pop = 'roll' !letter / 'pop' !letter
with = 'with' !letter
like = 'like' !letter

keyword
	= mysterious / plus / minus / times / over / as / isnt / not / is / put / into / let / be / listen / to / while
	/ until / else / if / build / up / down / knock / and / or / back / taking / give / takes / says / pronoun / the
	/ gtr / ltr / gte / lte / than / empty / true / false / null / print / non

_ = "" (whitespace / comment)+
whitespace = [ \t]
comment	=
	'#' [^\n]* '\n'
	/ '(' [^)]* ')'
	/ '{' [^\}]* '}'
	/ '[' [^\]]* ']'

EOB = EOS+
EOS = _? [.?!;]
	/ EOL
EOL = _? '\r'? '\n'
EOF = _? !.
	/ unexpected:("" [^ \t\r\n]+) 
		#error{ $"Unexpected '{unexpected.Replace("\r", "\\r").Replace("\n", "\\n")}' at line {state.Line}, col {state.Column - unexpected.Length}" }

@external propSource highlighting from "./highlight.js"

@top program {
	block
}

block {
     statement (EOS statement)*
}

statement {
     listen_stmt
  |  output_stmt
  |  function
  |  function_call
  |  call_stmt
  |  return_stmt
  |  break_stmt
  |  continue_stmt
  |  loop
  |  conditional
  |  declaration
  |  assignment
  |  enlistment
  |  increment
  |  decrement
  |  mutation
  |  rounding
  |  expression //LOOKAHEAD &EOS
}

enlistment {
     push expression into variable
  |  push variable with? expression_list
  |  push variable
  |  delist into assignable
  |  delist
}

delist {
     pop variable
}

listen_stmt {
     listen to variable |  listen
}

return_stmt {
     return back? expression back?
}

function {
     variable takes null consequent
  |  variable takes variable_list consequent
}

variable_list {
	variable _VLS_ variable_list
  |  variable
}

primary_list {
     primary _XLS_ primary_list
  |  primary _XLS_ primary
}

molecule_list {
     molecule _ALS_ argument_list
  |  molecule
}

argument_list {
     primary _ALS_ argument_list
  |  primary
}

argument {
     molecule
}

molecule {
     molecular_boolean
  |  primary
}

molecular_boolean {
     molecular_binary_or
}

molecular_binary_or {
     molecular_binary_nor or molecular_binary_or
  |  molecular_binary_nor
}

molecular_binary_nor {
     molecular_binary_and nor molecular_binary_nor
  |  molecular_binary_and
}

molecular_binary_and {
     molecular_equality and molecular_binary_and
  |  molecular_equality
}

molecular_equality {
     molecular_unary (_is
  |  _isnt) molecular_equality
  |  molecular_unary
}

molecular_unary {
     not_ molecular_unary
  |  molecular_comparison
}

molecular_comparison {
     molecular_addition comparator molecular_comparison
  |  molecular_addition
}

molecular_addition {
     molecular_addition (_plus_|_minus_) molecular_product
  |  molecular_product
}

molecular_product {
     molecular_product (_divide_|_times_) primary
  |  primary
}

expression_list {
     expression _ALS_ expression_list
  |  expression
}

oxford_comma {
     "," and
}

_nacton {
     "n'" | "'n'"
}

_VLS_ {
     and   |  _ALS_
}

_ALS_ {
     oxford_comma |  _XLS_
}

_XLS_ {
     (","   ("&"  )?)
  |  _nacton
  |    "&"
  |    ","
}

break_stmt {
     break wildcard
}

continue_stmt {
     continue wildcard
}

wildcard {
     letter* // LOOKAHEAD &EOS
}


consequent {
     EOS+ block EOB
  |  statement
}

if_test {
     if expression then?
}

conditional {
     if_test consequent   else consequent
  |  if_test consequent EOS+ else consequent
  |  if_test else consequent
  |  if_test EOS+ else consequent
  |  if_test  then? consequent
}

loop {
     while expression consequent
  |  until expression consequent
}

output_stmt {
     debug expression
  |  write expression
  |  print expression
}

binary_rhs {
     primary_list
  |  expression
}

index {
     at numeric_expression
}

indexes {
     index indexes
  |  index
}

assignable {
     variable indexes
  |  variable
}

declaration {
     let assignable be _operator_ expression_list
  |  let assignable be expression
  |  let assignable
}

assignment {
     put expression into assignable
  |  assignable says_ poetic_string
  |  assignable _is _operator_ expression_list
  |  assignable _is now expression
  |  assignable (  "="
  |  _is ) v1_poetic_number
  |  assignable (  "="
  |  _is ) expression
}

_operator_ {
     _plus_
  |  _minus_
  |  _times_
  |  _divide_
}

says_ {
     says ( " "? )
}

_is {
     _is exactly
  |  ("'s"
  |  "'re"
  |  is)
}

_isnt {
     _isnt exactly
  |  (_is not
  |  isnt)
}

variable {
     (his  identifier)
  |  pronoun
  |  proper_variable
  |  (the identifier)
  |   identifier
}

proper_variable {
     proper_noun proper_noun+
}

proper_noun {
     "Proper"
}

expression {
     boolean
  |  primary
}

boolean {
     binary_or
}

binary_or {
     binary_nor or binary_or
  |  binary_nor
}

binary_nor {
     binary_and nor binary_nor
  |  binary_and
}

binary_and {
     equality and binary_and
  |  equality
}

equality {
     unary (_is
  |  _isnt) equality
  |  unary
}

unary {
     not_ unary
  |  comparison
}

not_ {
     (not | non | non "-" )
}

comparison {
     addition comparator comparison
  |  addition
}

comparator {
     (  ">="    |  _is as as_great as )
  |  (  "<="    |  _is as as_small as )
  |  (  ">"    |  _is (above | more than) )
  |  (  "<"   | _is (under | less than) )
}

numeric_expression {
     addition
}

addition {
     addition (_plus_|_minus_) primary_list
  |  addition (_plus_|_minus_) product
  |  product
}

product {
     product (_divide_|_times_) primary_list
  |  product (_divide_|_times_) primary
  |  primary
}

_plus_ {
     (  "+"
  |  plus )
}

_minus_ {
     (  "-"
  |  minus )
}

_times_ {
     (  "*"
  |  times )
}

_divide_ {
     (  "|"
  |  divided_by )
}

primary {
     function_call
  |  delist
  |  constant
  |  string
  |  number
  |  lookup
}

call_stmt {
     call variable with argument_list into assignable
  |  call variable with argument_list
  |  call variable into assignable
  |  call variable
}

function_call {
     variable taking argument_list
}

lookup {
     variable indexes
  |  variable
}

increment {
     build variable ((  ",")?   up)+
}

decrement {
     knock variable ((  ",")?   down)+
}

mutator {
     split
  |  cast
  |  join
}

mutation {
     mutator expression into assignable using expression
  |  mutator expression using expression into assignable
  |  mutator expression into assignable
  |  mutator assignable using expression
  |  mutator assignable
}

rounding {
     floor
  |  ceil
  |  math_round
}

floor {
     turn variable down
  |  turn down variable
}

ceil {
     turn variable up
  |  turn up variable
}

math_round {
     turn variable around
  |  turn around variable
}

constant {
     null
  |  true
  |  false
  |  empty
  |  mysterious
}

number {
     like poetic_number
  |  digits
}

poetic_number {
     poetic_digits   ("..." |  "â€¦") poetic_digits
  |  poetic_digits
}

v1_digit_filter {
     "a lovestruck ladykiller" // &letter !keywords_which_can_begin_an_expression
}

v1_poetic_number {
       poetic_digits   (".") poetic_digits
  |    poetic_digits
}

poetic_digits {
     PDS* poetic_digit PDS+ poetic_digits PDS*
  |  poetic_digit
}

string {
     quoted_string+
}


keywords_which_can_begin_an_expression {
     plus
  |  minus
  |  times
  |  divided_by
  |  like
  |  and
  |  or
  |  nor
  |  not
  |  non
  |  null
  |  true
  |  false
  |  empty
  |  mysterious
}

keyword {
     keywords_which_can_begin_an_expression
  |  as
  |  as_great
  |  as_small
  |  back
  |  be
  |  build
  |  cast
  |  down
  |  else
  |  end
  |  false
  |  if
  |  into
  |  is
  |  isnt
  |  join
  |  knock
  |  less
  |  let
  |  listen
  |  more
  |  non
  |  not
  |  null
  |  or
  |  over
  |  print
  |  pronoun
  |  put
  |  return
  |  says
  |  split
  |  takes
  |  taking
  |  than
  |  the
  |  to
  |  until
  |  up
  |  while
}
_ {	(whitespace |  comment)+ }

whitespace {
	$[ \t]
}

@tokens {

	@precedence { _nacton, primary_list, statement, function_call }

	poetic_string {
		("" $[^\r\n]+)
   }


	EOB {
		EOL   EOL //LOOKAHEAD &EOL
	 |  EOL  //LOOKAHEAD&EOL
	 |  $[,?!.;]* EOL  //LOOKAHEAD &(  |  [,?!.;])? EOL)
	 |  EOS* //LOOKAHEAD &(  else)
	 |  EOS* ","?   end    |  $[,?!.;]*
	 |  EOS* ","?   end    |  $[,?!.;]*
	 |  EOS* ","?   "o" //LOOKEAHAD &("o"+ "h")
	 |  EOF
   }


	digits {
		("" (("-" |"+")? $[0-9]+ ("." $[0-9]+)?)
	 |  (("-" |"+")? "." $[0-9]+))
   }


	poetic_digit {
		("" (letter | $[\-"])+)
   }

	PDS {
		("" |  $[0-9\",;:?! ] )
   }

	quoted_string {
		"\"" (!["]*) "\""
   }


	identifier {
		letter (letter | $[0-9_])*
   }

	letter {
		@asciiLetter
   }

   uppercase_letter {
	   @asciiUppercase
   }

   lowercase_letter {
	   @asciiLowercase
   }


comment {
     "#" $[^\n]* "\n"
	 | "(" ![\)]* ")"
	 | "{" ![\}]* "}"
     | "[" ![\]]* "]"
}

EOS {
     $[,.?!;: \t]* EOL
  |    $[,.?!;:]
}

EOL {
       "\r"? "\n"
}

EOF {
     EOS*   @eof
}

above {
     "above"
  |  over
}

and {
     "and"
}

around {
     "around"
  |  "round"
}

as {
     "as"
}

as_great {
     "great" | "high" | "big" | "strong"
}

as_small {
     "less" | "low" | "small" | "weak"
}

at {
     "at"
}

back {
     "back"
}

be {
     "be"
}

break {
     "break"
}

build {
     "build"
}

call {
     "call"
}

cast {
     "cast"
  |  "burn"
}

continue {
     "continue"
  |  "take"
}

debug {
     "debug"
}

divided_by {
     "divided" "by"
  |  "between"
  |  over
}

down {
     "down"
}

else {
     "else"
  |  "otherwise"
}

empty {
     "empty"
  |  "silent"
  |  "silence"
}

end {
     "end"
  |  "yeah"
  |  "baby"
  |  "oh"
}

exactly {
     "exactly"
  |  "totally"
  |  "really"
}

false {
     "false" | "lies" | "no" | "wrong"
}

his {
     "his"
  |  "her"
}

if {
     "if"
  |  "when"
}

into {
     "into"
  |  "in"
}

is {
     "is"
  |  "was"
  |  "are"
  |  "were"
  |  "am"
}

isnt {
     "isnt"
  |  "isn't"
  |  "aint"
  |  "ain't"
  |  "wasn't"
  |  "wasnt"
  |  "aren't"
  |  "arent"
  |  "weren't"
  |  "werent"
}

join {
     "join"
  |  "unite"
}

knock {
     "knock"
}

less {
     "less" | "lower"
  |  "smaller" | "weaker"
}

let {
     "let"
}

like {
     "like"
  |  "so"
}

listen {
     "listen"
}

minus {
     "minus"
  |  "without"
}

more {
     "greater" | "higher"
  |  "bigger"
  |  "stronger"  | "more"
}

mysterious {
     "mysterious"
}

non {
     "non"
}

nor {
     "nor"
}

not {
     "not"
}

now {
     "now"
}

null {
     "null" | "nothing" | "nowhere" | "nobody" | "gone"
}

or {
     "or"
}

over {
     "over"
}

plus {
     "plus"
  |  "with"
}

pop {
     "roll"
  |  "pop"
}

print {
     "print"
  |  "shout"
  |  "say"
  |  "scream"
  |  "whisper"
}

pronoun {
     "they"
  |  "them"
  |  "she"
  |  "him"
  |  "her"
  |  "hir" | "zie" | "zir" | "xem" | "ver"
  |  "ze" | "ve" | "xe" | "it" | "he"
  |  "you"
  |  "me"
  |  "i"
}

push {
     "rock"
  |  "push"
}

put {
     "put"
}

return {
     "return"
  |  "giving"
  |  "give"
  |  "send"
}

says {
     "say"
  |  "says"
  |  "said"
}

split {
     "cut"
  |  "split"
  |  "shatter"
}

takes {
     "takes"
  |  "wants"
}

taking {
     "taking"
}

than {
     "than"
}

the {
     "an" | "a"
  |  "the"
  |  "my"
  |  "your"
  |  "our"
  |  "their"
}

then {
     "then"
}

times {
     "times"
  |  "of"
}

to {
     "to"
}

true {
     "true" | "yes" | "ok" | "right"
}

turn {
     "turn"
}

under {
     "under"
  |  "below"
}

until {
     "until"
}

up {
     "up"
}

using {
     "using"
  |  "with"
}

while {
     "while"
}

with {
     "with"
}

write {
     "write"
}
}
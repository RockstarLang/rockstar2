@namespace Rockstar.Engine
@classname Parser
@using System.Globalization
@using System.Text.RegularExpressions
@using Rockstar.Engine.Statements
@using Rockstar.Engine.Expressions
@using Rockstar.Engine.Values
@trace true

@ignorecase true

program <Block>
	= __ head:statements tail:program { head.Concat(tail) }
	/ __ EOF { new Block() }

__ = ("" _ / EOL)*

statements <Block>
	= head:statement EOS tail:statements { tail.Insert(head) }
	/ s:statement { new Block(s) }

EOS	= _? EOL _?
	/ _? EOF
	
EOL = '\r'? '\n'
EOF	= !.
	/ unexpected:("" [^ \t\r\n]+) 
		#error{ $"Unexpected '{Regex.Escape(unexpected)}' at line {state.Line}, col {state.Column - 1}" }

statement <Statement>
	= listen_stmt
	/ assign_stmt
	/ loop
	/ alternate
	/ output_stmt
	/ function_call
	/ return
	/ increment
	/ decrement


return <Return>
	= give _ e:expression _ back
		{ new Return(e, state.Source()) }
	/ give _ back _ e:expression
		{ new Return(e, state.Source()) }

function_call <FunctionCall>
	= name:variable _ taking _ args:expression_list
		{ new FunctionCall(name, args, state.Source()) }

expression_list <List<Expression>>
	= head:expression _XLS_ tail:expression_list
		{ head.Concat(tail) }
	/ expr:expression { new List<Expression> { expr } }

_XLS_
	= (_? ', ' and _ / _? ('&' / ',' / "'n'") _?)

_VLS_
	= _ and _ / _XLS_

variable_list <List<Variable>>
	= head:variable _VLS_ tail:variable_list
		{ head.Concat(tail) }
  / arg:variable { new List<Variable> { arg } }

noise 	= (_ / [;,])

increment <Increment>
	= build _ v:variable _ t:(up noise*)+
		{ new Increment(v, t.Count, state.Source()) }

decrement <Decrement>
	= knock _ v:variable _ t:(down noise*)+
		{ new Decrement(v, t.Count, state.Source()) }

block <Block>
	= _ s:statement
		{ new Block(s) }
	/ EOS b:statements 
		{ b }

alternate <Conditional>
	= if _ e:expression c:block else a:block
		{ new Conditional(e, c, state.Source()).Else(a) }
	/ if _ e:expression c:block _? else a:block
		{ new Conditional(e, c, state.Source()).Else(a) }
	/ if _ e:expression c:block EOS else a:block
		{ new Conditional(e, c, state.Source()).Else(a) }
	/ if _ e:expression c:block EOS
		{ new Conditional(e, c, state.Source()) }

loop <Loop>
	= while _ e:expression _ s:statement
		{ new WhileLoop(e, new Block(s), state.Source()) }
	/ while _ e:expression EOS b:statements EOS
		{ new WhileLoop(e, b, state.Source()) }
	/ until _ e:expression _ s:statement
		{ new UntilLoop(e, new Block(s), state.Source()) }
	/ until _ e:expression EOS b:statements EOS
		{ new UntilLoop(e, b, state.Source()) }

listen_stmt <Statement>
	= listen _ to _ v:variable
		{ new Listen(v, state.Source()) }
	/ listen
		{ new Listen(state.Source()) }

assign_stmt <Statement>
	= put _ e:expression _ into _ v:variable
		{ new Assign(v, e, state.Source()) }
	/ let _ v:variable _ be o:_op_ e:expression
		{ new Assign(v, new Binary(o, new Looküp(v, state.Source()), e, state.Source()), state.Source()) }
	/ let _ v:variable _ be _ e:expression
		{ new Assign(v, e, state.Source()) }
	/ name:variable _ takes _ args:variable_list EOS body:statements
		{ new Assign(name, new Function(args, body, state.Source()), state.Source()) }
	/ v:variable _ says _ s:("" [^\r\n]*) 
		{ new Assign(v, new Strïng(s, state.Source(s)), state.Source()) }
	/ v:variable _is _ l:(literal / poetic_literal)
		{ new Assign(v, l, state.Source()) }

	//TODO: reinstate for 2.0
	// v:variable _is _ e:expression { new Assign(v, e, state.Source()) }

poetic_literal <Number>
	= whole_part:poetic_digits _? '.' _? fractional_part:poetic_digits
		{ new Number (whole_part + "." + fractional_part) }
	/ digits:poetic_digits
		{ new Number(digits) }

PDS = ("" _ / [0-9\',;:?!+_/] )

poetic_digits <string>
	= PDS* head:poetic_digit PDS+ tail:poetic_digits PDS* 
		{ head + tail }
	/ d:poetic_digit
		{ d }

poetic_digit <string>
	= word:("" [A-Za-z\-']+)
		{ (Regex.Replace(word, "'+", "").Length % 10).ToString() }

output_stmt  <Statement>
	= output _ e:expression { new Output(e, state.Source()) }

variable <Variable>
	= p:pronoun { new Pronoun(p, state.Source(p)) }
	/ n:common_variable { new CommonVariable(n, state.Source(n)) }
	/ n:proper_variable { new ProperVariable(n, state.Source(n)) }
	/ n:simple_variable { new SimpleVariable(n, state.Source(n)) }

proper_variable	// e.g. Big Bad Benny
	= proper_noun (_ proper_noun)+

proper_noun
	= !keyword (uppercase_letter letter*)

common_variable
	= the _ identifier

identifier = ("" letter (letter / [0-9])*)
simple_variable	= !keyword identifier
letter	= uppercase_letter / lowercase_letter
uppercase_letter	= [A-ZÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĸĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸŹŻŽ]s
lowercase_letter	= [a-zàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĳĵķĸĺļľŀłńņňŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷÿźżžŉß]s

expression <Expression>
	= unary
	/ variable

unary <Expression>
	= op:unary_op ex:unary
		{ new Unary(op, ex, state.Source()) }
	/ primaroo

primaroo <Expression>
	= function_call
	/ binary_or

binary_or <Expression>
	= lhs:binary_and _ or _ rhs:binary_or
		{ new Binary(Operator.Or, lhs, rhs, state.Source()) }
	/ binary_and

binary_and <Expression>
	= lhs:equals _ and _ rhs:binary_and
		{ new Binary(Operator.And, lhs, rhs, state.Source()) }
	/ equals

equals <Expression>
	= lhs:compare op:_eq _ rhs:equals
		{ new Binary(op,lhs,rhs, state.Source()) }
	/ compare

//not <Expression>
//	= ('non-' / 'non' _ / 'not' _ ) ex:not { new Unary(Operator.Not, ex, state.Source()) }
//	/ compare

compare <Expression>
	= lhs:math op:comparator _ rhs:compare
		{ new Binary(op, lhs, rhs, state.Source()) }
	/ math

comparator <Operator>
	= _is _ gtr _ than { Operator.MoreThan }
	/ _is _ ltr _ than { Operator.LessThan }
	/ _is _ as _ gte _ as { Operator.MoreThanEqual }
	/ _is _ as _ lte _ as { Operator.LessThanEqual }

_eq
	= _is_not
	/ _is

_is <Operator>
	= ("'s" / "'re" / _ ('=' / is))
		{ Operator.Equals }

_is_not <Operator>
	= (_ '!=' / _is _ not / isnt)
		{ Operator.NotEquals }

math <Expression>
	= sum

sum <Expression> -memoize
	= lhs:sum op:(_plus_/_minus_) rhs:product { new Binary(op, lhs, rhs, state.Source()) }
	/ product

product <Expression> -memoize
	= lhs:product op:(_times_/_divide_) rhs:primary { new Binary(op, lhs, rhs, state.Source()) }
	/ primary

_plus_	<Operator>	= (_? '+' _? / _ plus _ ) { Operator.Plus }
_minus_	<Operator>	= (_? '-' _? / _ minus _ ) { Operator.Minus }
_times_	<Operator>	= (_? '*' _? / _ times _ ) { Operator.Times }
_divide_ <Operator>	= (_? '/' _? / _ over _ ) { Operator.Divide }

_op_ <Operator>
	= _plus_ / _minus_ / _times_ / _divide_

primary <Expression>
	= literal
	/ lookup

lookup <Expression>
	= v:variable
		{ new Looküp(v, state.Source()) }

literal <Expression>
	= constant
	/ number
	/ string

constant <Expression>
	= t:true { new Booleän(true, state.Source(t)) }
	/ f:false { new Booleän(false, state.Source(f)) }
	/ n:null { new Null(state.Source(n)) }
	/ m:mysterious { Mysterious.Instance }
	/ e:empty { Strïng.Empty }
string <Strïng>
	= '"' contents:("" [^"]*) '"' { new Strïng(contents, state.Source(contents)) }

number <Number>
    = digits:('-'? [0-9]+ ("." [0-9]+)?) { new Number(Decimal.Parse(digits), state.Source(digits) ) }
	/ digits:('-'? "." [0-9]+) { new Number(Decimal.Parse(digits), state.Source(digits) ) }

unary_op <Operator>
	= not { Operator.Not }
	/ _minus_ { Operator.Minus }


_	= "" (whitespace / comment)+
whitespace = [ \t]
comment	= '(' [^)]* ')'	/ '{' [^\}]* '}' / '[' [^\]]* ']'

mysterious = 'mysterious' !letter
plus = 'plus' !letter / 'with' !letter
minus = 'minus' !letter / 'without' !letter
times = 'times' !letter / 'of' !letter
over = 'over' !letter / 'between' !letter
as = 'as' !letter
isnt = "isnt" !letter / "isn't" !letter / 'aint' !letter / "ain't" !letter / "wasn't" !letter / "wasnt" !letter 
	/ "aren't" !letter / "arent" !letter / "weren't" !letter / "werent" !letter 
not = 'not' !letter 
is = 'is' !letter / 'was' !letter / 'are' !letter / 'were' !letter
put = 'put' !letter
into = 'into' !letter / 'in' !letter
let = 'let' !letter
be = 'be' !letter
listen = 'listen' !letter
to = 'to' !letter
while = 'while' !letter
until = 'until' !letter
else = 'else' !letter
if = 'if' !letter
build = 'build' !letter
up = 'up' !letter
down = 'down' !letter
knock = 'knock' !letter 
and = 'and' !letter
or = 'or' !letter
back = 'back' !letter
taking = 'taking' !letter
give = 'give' !letter / 'send' !letter
takes = 'takes' !letter / 'wants' !letter
says = 'says' !letter / 'said' !letter
pronoun	= 'they' !letter / 'them'!letter / 'she' !letter / 'him' !letter / 'her' !letter / 'hir' !letter/ 'zie' !letter/ 'zir' !letter/ 'xem' !letter/ 'ver'!letter
    / 'ze' !letter/ 've' !letter/ 'xe' !letter/ 'it' !letter/ 'he'!letter
the	= 'an'  !letter/ 'a'  !letter / 'the'  !letter / 'my'  !letter / 'your'  !letter / 'our' !letter
gtr = 'greater'/ 'higher' / 'bigger'	/ 'stronger' !letter/ 'more' !letter
ltr = 'less' !letter/ 'lower'	/ 'smaller' !letter/ 'weaker' !letter
gte = 'great' !letter/ 'high' !letter/ 'big' !letter/ 'strong' !letter
lte = 'less' !letter/ 'low' !letter/ 'small' !letter/ 'weak' !letter
than = 'than' !letter
empty = 'empty' !letter / 'silent' !letter / 'silence' !letter
true = "true" !letter/ "yes" !letter/ "ok" !letter/ "right"!letter 
false = "false" !letter/ "lies" !letter/ "no" !letter/ "wrong"!letter
null = 'null' !letter/ 'nothing' !letter/ 'nowhere' !letter/ 'nobody' !letter/ 'gone'!letter
output	= "shout" !letter / "say" !letter / "scream" !letter / "whisper" !letter


keyword = mysterious / plus / minus / times / over / as / isnt / not / is / put / into / let / be / listen / to / while / until / else / if / build / up / down / knock / and / or / back / taking / give / takes / says / pronoun / the / gtr / ltr / gte / lte / than / empty / true / false / null / output
